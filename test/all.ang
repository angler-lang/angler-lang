export (Nat, filter)

import Data.List (List)
import Data.List as L (_::_, Nil)

id : forall t:Type . t -> t
the : (select t:Type) -> t -> t

id x = x
the t x = id { t = t } x

_._ : forall a:Type, b:Type, c:Type . (b -> c) -> (a -> b) -> a -> c
(f . g) x = f (g x)

-- _$_ (infix 0) : forall a:Type, b:Type . (a -> b) -> a -> b

_$_ : forall a:Type, b:Type . (a -> b) -> a -> b
f $ x = f x

closed Nat : Type with
        Z : Nat
        S : Nat -> Nat

-- _._ {a = Nat, c = Nat} id id

-- open Char : Type
-- a' : Char
-- b' : Char
-- c' : Char
-- d' : Char
-- e' : Char

-- open Currency : Type
-- USD : Currency
-- EUR : Currency

-- USD = EUR

String : Type
String = List Char

closed Bool : Type with
        True  : Bool
        False : Bool

-- Bool = Nat           -- error: Bool is data type
-- True = False         -- error: True is constructor

reopen Type with
        Tipo : Type -> Type

open Count : Type with
        One : Count

open Currency : Type

reopen Currency with
        USD : Nat -> Currency
        EUR : Nat -> Currency

{-closed Bool : Type with
        closed True  : Bool with
                Yes  : True
                Yeap : True
        closed False : Bool with
                No : False
                Nope : False
        Bool = Char -}

-- macros higienicos
-- if True then if False then 1 else 2 else 3

if_then_else_ : forall t:Type . Bool -> t -> t -> t
if_then_else_ True yes _ = yes
if_then_else_ False _ no = no

closed Vect : forall t:Type . Nat -> t -> Type with
        Nil  : Vect Z t
        _::_ : forall n:Nat . t -> Vect n t -> Vect (S n) t

_+_ : t -> t -> t
        where t = Nat
-- t no está disponible aquí
Z     +   m = m
(S n) +   m = S (n + m)
_+_ Z     m = m
_+_ (S n) m = S (n + m)

filter : forall t:Type . (t -> Bool) -> List t -> List t
-- filter g (x :: xs) {t = tpe} =
--         (if g x
--                 then _::_ x
--                 else the (List tpe)) filter g xs
filter g (x L.:: xs) =
        (if g x
                then _::_ x
                else id) filter g xs
filter _ (L.Nil) = L.Nil

filterVect : forall t:Type, n:Nat . (t -> Bool) -> Vect n t -> exists (m:Nat ; Vect m t)
filterVect g (x :: xs) = (if g x then _::_ x else id) filterVect g xs
filterVect _ (Nil    ) = Nil
-- filterVect g (x :: xs) {n = S nxt} = (if g x then _::_ x else id) filterVect {n = nxt} g xs
-- filterVect _ (Nil    ) {n = Z    } = Nil

-- map : forall

const : forall a:Type, b:Type . a -> b -> b
const = \ _ x -> x

zeroes : List Nat -> List Nat
zeroes = filter $ \Z -> True

ones : List Nat -> List Nat
ones = map S . zeroes

firstZ : forall n:Nat . Vect n Nat -> Nat
firstZ (Z :: xs) = Z
firstZ (_ :: xs) = S (firstZ xs)
-- firstZ Nil       = error "no Z in Vect"      -- no strings yet

_=_ : Type -> Type -> Type
(a = b) = a               -- parses a = «b = a»

-- f : (Type -> Type -> Type) -> Nat -> Nat
-- f = \ -> n -> n      -- parse error: no arguments for lambda

-- : : String -> Type -> (String & Type) -- parser error: ':' unexpected
:* : String -> Type -> (String & Type)
:* str typ = str /\ typ