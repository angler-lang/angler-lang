export (Nat, filter)

import List as L (_::_, Nil)
import List (List)

id : forall t:Type . t -> t
the : (select t:Type) -> t -> t

id x = x
the t x = id { t = t } x

-- probably impossible
-- typeOf : exists t:Type ; t -> t
-- typeOf x = x
typeOf : forall x:Type . x -> (exists t:Type1 . (select x : t))
typeOf x = x

operator _._ infixL 10
_._ : forall a:Type, b:Type, c:Type . (b -> c) -> (a -> b) -> a -> c
(f . g) x = f (g x)

operator _$_ infixL 1
_$_ : forall a:Type, b:Type . (a -> b) -> a -> b
f $ x = f x

closed Nat : Type with
        Z : Nat
        S : Nat -> Nat

String : Type
String = List Char

closed Bool : Type with
        True  : Bool
        False : Bool

-- Bool = Nat           -- error: Bool is data type
-- True = False         -- error: True is constructor

reopen Type with
        Tipo : Type -> Type

open Count : Type

reopen Count with
        One : Count

reopen Count with
        Two : Count

open Currency : Type with
        USD : Nat -> Currency
        EUR : Nat -> Currency

foldr : forall x:Type, y:Type . (x -> y -> y) -> y -> List x -> y
foldr f (x :: xs) y = f x rest
        where
                rest = foldr f xs y
foldr _ Nil       y = y

operator if_then_else_ prefix 0
if_then_else_ : forall t:Type . Bool -> t -> t -> t
if_then_else_ True yes _ = yes
if_then_else_ False _ no = no

closed Vect : Nat -> (select t:Type) -> Type with
        Nil  : Vect Z t
        _::_ : forall n:Nat . t -> Vect n t -> Vect (S n) t

operator _+_ infixL 3
_+_ : t -> t -> t
        where t = Nat
-- t no está disponible aquí
Z     +   m = m
(S n) +   m = S (n + m)
_+_ Z     m = m
_+_ (S n) m = S (n + m)

filter : forall t:Type . (t -> Bool) -> List t -> List t
filter g (x L.:: xs) =
        (if g x
                then L._::_ x
                else id) filter g xs
filter _ (L.Nil) = L.Nil

filterVect : forall t:Type, n:Nat . (t -> Bool) -> Vect n t -> exists m:Nat . Vect m t
filterVect g (x :: xs) = (if g x then _::_ x else id) filterVect g xs
filterVect _ (Nil    ) = Nil
-- filterVect g (x :: xs) {n = S nxt} = (if g x then _::_ x else id) filterVect {n = nxt} g xs
-- filterVect _ (Nil    ) {n = Z    } = Nil

-- map : forall

const : forall a:Type, b:Type . a -> b -> b
const = \ _ x -> x

zeroes : List Nat -> List Nat
zeroes = filter $ \Z -> True

ones : List Nat -> List Nat
ones = map S . zeroes

firstZ : forall n:Nat . Vect n Nat -> Nat
firstZ (Z :: xs) = Z
firstZ (_ :: xs) = S (firstZ xs)
-- firstZ Nil       = error "no Z in Vect"      -- no strings yet

operator _=_ infixL 9
_=_ : Type -> Type -> Type
(a = b) = a               -- parses a = «b = a»

-- f = \ -> n -> n      -- parse error: no arguments for lambda

-- : : String -> Type -> (String & Type) -- parser error: ':' unexpected
:* : String -> Type -> (String & Type)
:* str typ = str /\ typ

f : Nat
f = 2 + let a = 3
            b = a + 2 in a
